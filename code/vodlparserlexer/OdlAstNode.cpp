#include "BasicTypes.h"
#include "OdlAstNode.h"


namespace odl
{
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
static odl::TOdlAstNodeIdentifier* AutoGenerateObjectIdentifier()
{
    static unsigned int number = 0;
    char buffer[64];
    sprintf_s(buffer, "autoname#%010u", number);
    number++;

    odl::TOdlAstNodeIdentifier* autoGeneratedIdentifier = new odl::TOdlAstNodeIdentifier(std::string(buffer));
    return autoGeneratedIdentifier;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode(TOdlAstNodeType::TType parAstNodeType) :
    FAstNodeType(parAstNodeType),
    FPropertyList(),
    FIdentifierPointer(nullptr),
    FTypeIdentifierPointer(nullptr),
    FTargetTemplateNamespaceIdentifierPointer(nullptr),
    FPropertyDeclarationListPointer(nullptr),
    FExpressionPointer(nullptr),
    FTemplateParameterListPointer(nullptr),
    FResolvedReferenceWeak(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FReferenceToResolve(false),
    FIsValueReference(false),
    FIsTemplateDeclarationParameter(false)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode() :
    FAstNodeType(TOdlAstNodeType::UNKNOWN),
    FPropertyList(),
    FIdentifierPointer(nullptr),
    FTypeIdentifierPointer(nullptr),
    FTargetTemplateNamespaceIdentifierPointer(nullptr),
    FPropertyDeclarationListPointer(nullptr),
    FExpressionPointer(nullptr),
    FTemplateParameterListPointer(nullptr),
    FResolvedReferenceWeak(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FReferenceToResolve(false),
    FIsValueReference(false),
    FIsTemplateDeclarationParameter(false)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::~TOdlAstNode()
{
    for (size_t i = 0; i < FPropertyList.size(); ++i)
    {
        TOdlAstNode const* node = FPropertyList[i];
        delete node;
    }

    for (size_t i = 0; i < FNamedDeclarationList.size(); ++i)
    {
        TOdlAstNode const* node = FNamedDeclarationList[i];
        delete node;
    }


    for (size_t i = 0; i < FTemplateParameterList.size(); ++i)
    {
        TOdlAstNode const* node = FTemplateParameterList[i];
        delete node;
    }
    
    delete FIdentifierPointer;
    delete FTypeIdentifierPointer;
    delete FTargetTemplateNamespaceIdentifierPointer;
    delete FPropertyDeclarationListPointer;
    delete FExpressionPointer;
    delete FTemplateParameterListPointer;

    FResolvedReferenceWeak = nullptr; // weak reference.
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetIdentifierPointer(TOdlAstNodeIdentifier* parIdentifierPointer)
{
    assert(FIdentifierPointer == nullptr);
    FIdentifierPointer = parIdentifierPointer;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::AutoGenerateIdentifier()
{
    assert(FIdentifierPointer == nullptr);
    FIdentifierPointer = AutoGenerateObjectIdentifier();
    FAnonymousDeclaration = true;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNamespace()
{
    FAstNodeType = TOdlAstNodeType::NAMESPACE;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::Namespace_SetTemplateParameterList(TOdlAstNode* parTemplateArgumentListPointer)
{
    assert(FAstNodeType == TOdlAstNodeType::NAMESPACE);
    FTemplateParameterListPointer = parTemplateArgumentListPointer;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNamespaceTemplateInstanciation(TOdlAstNodeIdentifier* parIdentifier, TOdlAstNodeIdentifier* parTargetTemplateNamespaceIdentifierPointer, TOdlAstNode* parTemplateExpressionList)
{
    FAstNodeType = TOdlAstNodeType::NAMESPACE;

    assert(parIdentifier != nullptr);
    assert(parTargetTemplateNamespaceIdentifierPointer != nullptr);
    assert(parTemplateExpressionList != nullptr);

    assert(parIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTargetTemplateNamespaceIdentifierPointer->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTemplateExpressionList->AstNodeType() == TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST);

    FIdentifierPointer = parIdentifier;
    FTargetTemplateNamespaceIdentifierPointer = parTargetTemplateNamespaceIdentifierPointer;
    FTemplateParameterListPointer = parTemplateExpressionList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::Namespace_AppendNamedDeclaration(TOdlAstNode* parDeclaration)
{
    assert(FAstNodeType == TOdlAstNodeType::NAMESPACE);
    FNamedDeclarationList.push_back(parDeclaration);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsObjectTemplateDeclaration(TOdlAstNodeIdentifier* parIdentifier, TOdlAstNodeIdentifier* parTypeIdentifier, TOdlAstNode* parTemplateParameterList, TOdlAstNode* parPropertyList)
{
    FAstNodeType = TOdlAstNodeType::OBJECT_TEMPLATE_DECLARATION;

    assert(parIdentifier != nullptr);
    assert(parTypeIdentifier != nullptr);
    assert(parTemplateParameterList != nullptr);
    assert(parPropertyList != nullptr);

    assert(parIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTypeIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTemplateParameterList->AstNodeType() == TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST);
    assert(parPropertyList->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);

    FIdentifierPointer = parIdentifier;
    FTypeIdentifierPointer = parTypeIdentifier;
    FTemplateParameterListPointer = parTemplateParameterList;
    FPropertyDeclarationListPointer = parPropertyList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateDeclarationParameterList()
{
    FAstNodeType = TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::TemplateDeclarationParameterList_AppendParameter(TOdlAstNodeIdentifier* parIdentifier)
{
    assert(FAstNodeType == TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST);
    assert(parIdentifier->IsTemplateDeclarationParameter());
    FTemplateParameterList.push_back(parIdentifier);
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateInstanciationParameterList()
{
    FAstNodeType = TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::TemplateInstanciationParameterList_AppendParameter(TOdlAstNode* parExpression)
{
    assert(FAstNodeType == TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST);

    assert(parExpression != nullptr);
    assert((parExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION_MASK) != 0);
    FTemplateParameterList.push_back(parExpression);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateInstanciation(TOdlAstNodeIdentifier* parTypeIdentifier, TOdlAstNode* parTemplateExpressionList)
{
    FAstNodeType = TOdlAstNodeType::OBJECT_TEMPLATE_INSTANCIATION;

    assert(parTypeIdentifier != nullptr);
    assert(parTemplateExpressionList != nullptr);

    assert(parTypeIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTemplateExpressionList->AstNodeType() == TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST);

    FTypeIdentifierPointer = parTypeIdentifier;
    FTemplateParameterListPointer = parTemplateExpressionList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNamedDeclaration(TOdlAstNodeIdentifier* parNameIdentifier, TOdlAstNode* parExpression)
{
    FAstNodeType = TOdlAstNodeType::NAMED_DECLARATION;
    
    assert(parExpression != nullptr);
    assert(parNameIdentifier != nullptr);

    FIdentifierPointer = parNameIdentifier;
    FExpressionPointer = parExpression;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsObjectDeclaration(TOdlAstNodeIdentifier* parTypeIdentifier, TOdlAstNode* parPropertyList)
{
    FAstNodeType = TOdlAstNodeType::OBJECT_DECLARATION;

    assert(parTypeIdentifier != nullptr);
    assert(parPropertyList != nullptr);

    assert(parTypeIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parPropertyList->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);

    FTypeIdentifierPointer = parTypeIdentifier;
    FPropertyDeclarationListPointer = parPropertyList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNullPtr()
{
    FAstNodeType = TOdlAstNodeType::OBJECT_DECLARATION;    

}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
bool TOdlAstNode::IsNullPtr() const
{
    if (FAstNodeType == TOdlAstNodeType::OBJECT_DECLARATION)
    {
        if (FTypeIdentifierPointer == nullptr)
        {
            if (FPropertyDeclarationListPointer == nullptr)
                return true;
            assert(false); // non typed object.
        }

        return false;
    }

    assert(false); // IsNullPtr valid on object type only.

    return false;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsPropertyDeclarationList()
{
    FAstNodeType = TOdlAstNodeType::PROPERTY_DECLARATION_LIST;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PropertyDeclarationList_AppendPropertyDeclaration(TOdlAstNode* parPropertyDeclarationNode)
{
    assert(FAstNodeType == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);
    assert(parPropertyDeclarationNode != nullptr);
    assert(parPropertyDeclarationNode->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION);
    FPropertyList.push_back(parPropertyDeclarationNode);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsPropertyDeclaration(TOdlAstNodeIdentifier* parIdentifier, TOdlAstNode* parExpression)
{
    assert(parIdentifier != nullptr);
    assert(parIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parExpression != nullptr);
    assert(parExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION);

    FAstNodeType = TOdlAstNodeType::PROPERTY_DECLARATION;
    FIdentifierPointer = parIdentifier;
    FExpressionPointer = parExpression;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrint(std::ostringstream& parOss) const
{
    PrettyPrintWithIndentLevel(parOss, 0);
}
//-------------------------------------------------------------------------------
std::ostringstream& Indent(std::ostringstream& parOss, int parIndentLevel)
{
    for (int i = 0; i < parIndentLevel; ++i)
    {
        parOss << ".";
    }

    return parOss;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrintWithIndentLevel(std::ostringstream& parOss, int parIndentLevel) const
{
    switch (FAstNodeType)
    {
    case TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST:
        {
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNode const* parameter : FTemplateParameterList)
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                parameter->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
            parOss << ')';
        }
        break ;
    case TOdlAstNodeType::OBJECT_TEMPLATE_INSTANCIATION:
        {
            parOss << FTypeIdentifierPointer->Identifier(); // template name.
            FTemplateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;    
        }
        break ;
    case TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST:
        {
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNode const* parameter : FTemplateParameterList)
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                // {TODO} Paul(2014/12/21) strong typing.
                parOss << parameter->CastNode<TOdlAstNodeIdentifier>()->Identifier();
            }
            parOss << ')';
        }
        break;
    case TOdlAstNodeType::OBJECT_TEMPLATE_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
            parOss << "template ";
            parOss << FIdentifierPointer->Identifier();
            parOss << " is ";
            parOss << FTypeIdentifierPointer->Identifier();
            FTemplateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            FPropertyDeclarationListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel) << "}";
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::EXPRESSION:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
                int const propertyLengthPlusSpacePlusIsPlusSpace = (int) FIdentifierPointer->Identifier().length() + 4;
                parIndentLevel += propertyLengthPlusSpacePlusIsPlusSpace;
            }

            parOss << "(" << std::endl;
            if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer() != nullptr)
            {
                Indent(parOss, parIndentLevel + 4);
                CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->AstNodeType() != TOdlAstNodeType::EXPRESSION)
                    parOss << std::endl;
            }
            CastNode<TOdlAstNodeOperation>()->OperatorExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel + 4);
            CastNode<TOdlAstNodeOperation>()->RightExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << ")" << std::endl;
        }
        break ;
    case TOdlAstNodeType::OPERATOR:
    {
        TOdlAstNodeOperatorType::TType operatorType = CastNode<TOdlAstNodeOperator>()->OperatorType();
        switch (operatorType)
        {
        case TOdlAstNodeOperatorType::OPERATOR_PLUS:
            {
                Indent(parOss, parIndentLevel) << '+' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MINUS:
            {
                Indent(parOss, parIndentLevel) << '-' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MULTIPLY:
            {
                Indent(parOss, parIndentLevel) << '*' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_DIVIDE:
            {
                Indent(parOss, parIndentLevel) << '/' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MODULO:
            {
                Indent(parOss, parIndentLevel) << '%' << std::endl;
            }
            break ;
        default:
            assert(false);
            break ;
        };

        }    
        break ;
    case TOdlAstNodeType::IDENTIFIER:
        {
            TOdlAstNodeIdentifier const* nodeIdentifier = CastNode<TOdlAstNodeIdentifier>();
            parOss << nodeIdentifier->Identifier() << std::endl;
        }
        break ;
    case TOdlAstNodeType::VALUE_STRING:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss << "\"";
            parOss << this->CastNode<TOdlAstNodeValue>()->ValueString().c_str();
            parOss << "\"";

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_INTEGER:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueInteger();

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_FLOAT:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueFloat();

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_VECTOR:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }


            TOdlAstNodeValueVector const* valueVectorNode = CastNode<TOdlAstNodeValueVector>();
            std::vector< TOdlAstNodeExpression* > const& vectorContent = valueVectorNode->VectorContent();
            parOss << '[';
            for (int i = 0; i < (int) vectorContent.size(); ++i)
            {
                // PAUL(15/05/14 18:19:11) les items sont stockés à l'envers 
                // (description de la grammaire permet de supporter la notation [ expression , ]
                int const invI = (int) vectorContent.size() - i - 1;
                TOdlAstNode const* item = vectorContent[invI];
                item->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
                if (i + 1 != vectorContent.size())
                    parOss << ", ";
            }
            parOss << ']';

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
            parOss << FIdentifierPointer->Identifier();
            parOss << " = ";

            int const propertyLengthPlusSpacePlusEqualPlusSpace = (int) FIdentifierPointer->Identifier().length() + 3;
            FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + propertyLengthPlusSpacePlusEqualPlusSpace);
            // yuk.
            if (FExpressionPointer->AstNodeType() != TOdlAstNodeType::EXPRESSION)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION_LIST:
        {
            for (size_t i = 0; i < FPropertyList.size(); ++i)
            {
                TOdlAstNode const* child = FPropertyList[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
        }
        break ;
    case TOdlAstNodeType::OBJECT_DECLARATION:
        {
            if (IsNullPtr())
            {
                parOss << "<nullptr>" << std::endl;
            }
            else
            {
                if (FIdentifierPointer != nullptr)
                {
                    parOss << "[";
                    parOss << FIdentifierPointer->Identifier();
                    parOss << "] ";
                }

                parOss << FTypeIdentifierPointer->Identifier() << std::endl;

                Indent(parOss, parIndentLevel) << "{" << std::endl;
                FPropertyDeclarationListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                Indent(parOss, parIndentLevel) << "}";
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::NAMESPACE:
        {
            Indent(parOss, parIndentLevel) << "namespace ";
            if (FIdentifierPointer != nullptr)
            {
                parOss << FIdentifierPointer->Identifier();
            }

            if (FTemplateParameterListPointer != nullptr)
            {
                FTemplateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }

            parOss << std::endl;
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            for (size_t i = 0; i < FNamedDeclarationList.size(); ++i)
            {
                TOdlAstNode const* child = FNamedDeclarationList[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            }
            Indent(parOss, parIndentLevel) << "}" << std::endl;
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::NAMED_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
            parOss << FIdentifierPointer->Identifier();
            parOss << " is ";
            int const identifierLengthPlusSpaceIsSpace = (int) FIdentifierPointer->Identifier().length() + 4;
            FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + identifierLengthPlusSpaceIsSpace);
            parOss << std::endl;
        }
        break ;
    };
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsReferenceToResolve()
{
    FReferenceToResolve = true;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::ResolveReference(TOdlAstNode const* parNodeReference)
{
    FResolvedReferenceWeak = parNodeReference; 
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetFullDatabasePath(TOdlDatabasePath const& parFullDatabasePath)
{
    FFullDatabasePath = parFullDatabasePath;
}
//-------------------------------------------------------------------------------
bool TOdlAstNode::IsGlobalNamespace() const
{
    assert(FAstNodeType == TOdlAstNodeType::NAMESPACE);
    return FIdentifierPointer == nullptr;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::BreakPoint()
{
    int a = 0;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
} // namespace odl
