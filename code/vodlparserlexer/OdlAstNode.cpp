#include "BasicTypes.h"
#include "OdlAstNode.h"


namespace odl
{
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
static odl::TOdlAstNode* AutoGenerateObjectIdentifier()
{
	static unsigned int number = 0;
	char buffer[64];
	sprintf_s(buffer, "autoname#%010u", number);
	number++;

	odl::TOdlAstNode* autoGeneratedIdentifier = new odl::TOdlAstNode();
	autoGeneratedIdentifier->SetAsIdentifier(std::string(buffer));
	return autoGeneratedIdentifier;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode() :
    FAstNodeType(TOdlAstNodeType::UNKNOWN),
    FOperatorType(TOdlAstNodeOperatorType::OPERATOR_NONE),
    FValueIdentifier(),
    FValueString(),
    FValueInteger(0),
    FValueFloat(0.0f),
    FPropertyList(),
    FIdentifierPointer(nullptr),
    FTypeIdentifierPointer(nullptr),
    FPropertyDeclarationListPointer(nullptr),
    FExpressionPointer(nullptr),
	FTemplateParameterListPointer(nullptr),
    FLeftExpressionPointer(nullptr),
    FOperatorExpressionPointer(nullptr),
    FRightExpressionPointer(nullptr),
    FResolvedReferenceWeak(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FReferenceToResolve(false),
    FIsValueReference(false)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::~TOdlAstNode()
{
    for (size_t i = 0; i < FPropertyList.size(); ++i)
    {
        TOdlAstNode const* node = FPropertyList[i];
        delete node;
    }

    for (size_t i = 0; i < FNamedDeclarationList.size(); ++i)
    {
        TOdlAstNode const* node = FNamedDeclarationList[i];
        delete node;
    }

    for (size_t i = 0; i < FVectorContent.size(); ++i)
    {
        TOdlAstNode const* node = FVectorContent[i];
        delete node;
    }

	for (size_t i = 0; i < FTemplateParameterList.size(); ++i)
	{
		TOdlAstNode const* node = FTemplateParameterList[i];
        delete node;
	}
    
    delete FIdentifierPointer;
    delete FTypeIdentifierPointer;
    delete FPropertyDeclarationListPointer;
    delete FExpressionPointer;
    delete FLeftExpressionPointer;
    delete FOperatorExpressionPointer;
    delete FRightExpressionPointer;
	delete FTemplateParameterListPointer;

    FResolvedReferenceWeak = nullptr; // weak reference.
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetIdentifierPointer(TOdlAstNode* parIdentifierPointer)
{
    assert(FIdentifierPointer == nullptr);
    FIdentifierPointer = parIdentifierPointer;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::AutoGenerateIdentifier()
{
    assert(FIdentifierPointer == nullptr);
    FIdentifierPointer = AutoGenerateObjectIdentifier();
    FAnonymousDeclaration = true;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNamespace()
{
    FAstNodeType = TOdlAstNodeType::NAMESPACE;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::Namespace_AppendNamedDeclaration(TOdlAstNode* parDeclaration)
{
    assert(FAstNodeType == TOdlAstNodeType::NAMESPACE);
    FNamedDeclarationList.push_back(parDeclaration);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateDeclaration(TOdlAstNode* parIdentifier, TOdlAstNode* parTypeIdentifier, TOdlAstNode* parTemplateParameterList, TOdlAstNode* parPropertyList)
{
    FAstNodeType = TOdlAstNodeType::OBJECT_TEMPLATE_DECLARATION;

	assert(parIdentifier != nullptr);
	assert(parTypeIdentifier != nullptr);
    assert(parTemplateParameterList != nullptr);
	assert(parPropertyList != nullptr);

	assert(parIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTypeIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parTemplateParameterList->AstNodeType() == TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST);
	assert(parPropertyList->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);

	FIdentifierPointer = parIdentifier;
	FTypeIdentifierPointer = parTypeIdentifier;
	FTemplateParameterListPointer = parTemplateParameterList;
	FPropertyDeclarationListPointer = parPropertyList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateDeclarationParameterList()
{
	FAstNodeType = TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::TemplateDeclarationParameterList_AppendParameter(TOdlAstNode* parIdentifier)
{
	assert(FAstNodeType == TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST);
	FTemplateParameterList.push_back(parIdentifier);
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateInstanciationParameterList()
{
	FAstNodeType = TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::TemplateInstanciationParameterList_AppendParameter(TOdlAstNode* parExpression)
{
	assert(FAstNodeType == TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST);

	assert(parExpression != nullptr);
	assert((parExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION_MASK) != 0);
	FTemplateParameterList.push_back(parExpression);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateInstanciation(TOdlAstNode* parTypeIdentifier, TOdlAstNode* parTemplateExpressionList)
{
    FAstNodeType = TOdlAstNodeType::OBJECT_TEMPLATE_INSTANCIATION;

	assert(parTypeIdentifier != nullptr);
	assert(parTemplateExpressionList != nullptr);

	assert(parTypeIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
	assert(parTemplateExpressionList->AstNodeType() == TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST);

	FTypeIdentifierPointer = parTypeIdentifier;
	FTemplateParameterListPointer = parTemplateExpressionList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNamedDeclaration(TOdlAstNode* parNameIdentifier, TOdlAstNode* parExpression)
{
	FAstNodeType = TOdlAstNodeType::NAMED_DECLARATION;
	
	assert(parExpression != nullptr);
	assert(parNameIdentifier != nullptr);

	FIdentifierPointer = parNameIdentifier;
	FExpressionPointer = parExpression;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsObjectDeclaration(TOdlAstNode* parTypeIdentifier, TOdlAstNode* parPropertyList)
{
    FAstNodeType = TOdlAstNodeType::OBJECT_DECLARATION;

    assert(parTypeIdentifier != nullptr);
    assert(parPropertyList != nullptr);

    assert(parTypeIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parPropertyList->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);

    FTypeIdentifierPointer = parTypeIdentifier;
    FPropertyDeclarationListPointer = parPropertyList;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNullPtr()
{
	FAstNodeType = TOdlAstNodeType::OBJECT_DECLARATION;	

}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
bool TOdlAstNode::IsNullPtr() const
{
	if (FAstNodeType == TOdlAstNodeType::OBJECT_DECLARATION)
	{
		if (FTypeIdentifierPointer == nullptr)
		{
			if (FPropertyDeclarationListPointer == nullptr)
				return true;
			assert(false); // non typed object.
		}

		return false;
	}

	assert(false); // IsNullPtr valid on object type only.

	return false;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsPropertyDeclarationList()
{
    FAstNodeType = TOdlAstNodeType::PROPERTY_DECLARATION_LIST;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PropertyDeclarationList_AppendPropertyDeclaration(TOdlAstNode* parPropertyDeclarationNode)
{
    assert(FAstNodeType == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);
    assert(parPropertyDeclarationNode != nullptr);
    assert(parPropertyDeclarationNode->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION);
    FPropertyList.push_back(parPropertyDeclarationNode);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsPropertyDeclaration(TOdlAstNode* parIdentifier, TOdlAstNode* parExpression)
{
    assert(parIdentifier != nullptr);
    assert(parIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parExpression != nullptr);
    assert(parExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION);

    FAstNodeType = TOdlAstNodeType::PROPERTY_DECLARATION;
    FIdentifierPointer = parIdentifier;
    FExpressionPointer = parExpression;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsIdentifier(std::string const& parIdentifier)
{
    FAstNodeType = TOdlAstNodeType::IDENTIFIER;
    FValueIdentifier = parIdentifier;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsStringValue(std::string const& parStringValue)
{
    FAstNodeType = TOdlAstNodeType::VALUE_STRING;
    FValueString = parStringValue;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsIntegerValue(int parIntegerValue)
{
    FAstNodeType = TOdlAstNodeType::VALUE_INTEGER;
    FValueInteger = parIntegerValue;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsFloatValue(float parFloatValue)
{
    FAstNodeType = TOdlAstNodeType::VALUE_FLOAT;
    FValueFloat = parFloatValue;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsOperator(TOdlAstNodeOperatorType::TType parOperatorType)
{
    FAstNodeType = TOdlAstNodeType::OPERATOR;
    FOperatorType = parOperatorType;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsExpression(TOdlAstNode* parLeftExpression,
                                  TOdlAstNode* parOperator,
                                  TOdlAstNode* parRightExpression)
{
    FAstNodeType = TOdlAstNodeType::EXPRESSION;

	assert(parRightExpression != nullptr);
	assert(parOperator != nullptr);
	if (parOperator->OperatorType() != TOdlAstNodeOperatorType::OPERATOR_MINUS)
	{
		assert(parLeftExpression != nullptr);
	}
	
	assert(parLeftExpression != nullptr ? parLeftExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION_MASK : true);
    assert(parRightExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION_MASK);
    assert(parOperator->AstNodeType() == TOdlAstNodeType::OPERATOR);

    FLeftExpressionPointer = parLeftExpression;
    FOperatorExpressionPointer = parOperator;
    FRightExpressionPointer = parRightExpression;    
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsVector()
{
	FAstNodeType = TOdlAstNodeType::VALUE_VECTOR;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::Vector_AppendItem(TOdlAstNode* parVectorItem)
{
	assert(AstNodeType() == TOdlAstNodeType::VALUE_VECTOR);

	FVectorContent.push_back(parVectorItem);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrint(std::ostringstream& parOss) const
{
    PrettyPrintWithIndentLevel(parOss, 0);
}
//-------------------------------------------------------------------------------
std::ostringstream& Indent(std::ostringstream& parOss, int parIndentLevel)
{
    for (int i = 0; i < parIndentLevel; ++i)
    {
        parOss << ".";
    }

    return parOss;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrintWithIndentLevel(std::ostringstream& parOss, int parIndentLevel) const
{
    switch (FAstNodeType)
    {
	case TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST:
		{
			parOss << '(';
			bool printComma = false;
			for (TOdlAstNode const* parameter : FTemplateParameterList)
			{
				if (printComma)
					parOss << ", ";
				printComma = true;
				parameter->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
			}
			parOss << ')';
		}
		break ;
	case TOdlAstNodeType::OBJECT_TEMPLATE_INSTANCIATION:
		{
			parOss << FTypeIdentifierPointer->Identifier(); // template name.
			FTemplateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
			parOss << std::endl;	
		}
		break ;
	case TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST:
		{
			parOss << '(';
			bool printComma = false;
			for (TOdlAstNode const* parameter : FTemplateParameterList)
			{
				if (printComma)
					parOss << ", ";
				printComma = true;
				parOss << parameter->Identifier();
			}
			parOss << ')';
		}
		break;
	case TOdlAstNodeType::OBJECT_TEMPLATE_DECLARATION:
		{
			Indent(parOss, parIndentLevel);
			parOss << "template ";
			parOss << FIdentifierPointer->Identifier();
			parOss << " is ";
			parOss << FTypeIdentifierPointer->Identifier();
			FTemplateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
			parOss << std::endl;
			Indent(parOss, parIndentLevel) << "{" << std::endl;
			FPropertyDeclarationListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
			Indent(parOss, parIndentLevel) << "}";
			parOss << std::endl;
		}
		break ;
	case TOdlAstNodeType::EXPRESSION:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
                int const propertyLengthPlusSpacePlusIsPlusSpace = (int) FIdentifierPointer->Identifier().length() + 4;
                parIndentLevel += propertyLengthPlusSpacePlusIsPlusSpace;
            }

			parOss << "(" << std::endl;
			if (FLeftExpressionPointer != nullptr)
            {
                Indent(parOss, parIndentLevel + 4);
				FLeftExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                if (FLeftExpressionPointer->AstNodeType() != TOdlAstNodeType::EXPRESSION)
                    parOss << std::endl;
            }
			FOperatorExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel + 4);
			FRightExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            parOss << std::endl;
			Indent(parOss, parIndentLevel) << ")" << std::endl;
		}
		break ;
	case TOdlAstNodeType::OPERATOR:
	{
		switch (FOperatorType)
		{
		case TOdlAstNodeOperatorType::OPERATOR_PLUS:
			{
				Indent(parOss, parIndentLevel) << '+' << std::endl;
			}
			break ;
		case TOdlAstNodeOperatorType::OPERATOR_MINUS:
			{
				Indent(parOss, parIndentLevel) << '-' << std::endl;
			}
			break ;
		case TOdlAstNodeOperatorType::OPERATOR_MULTIPLY:
			{
				Indent(parOss, parIndentLevel) << '*' << std::endl;
			}
			break ;
		case TOdlAstNodeOperatorType::OPERATOR_DIVIDE:
			{
				Indent(parOss, parIndentLevel) << '/' << std::endl;
			}
			break ;
		case TOdlAstNodeOperatorType::OPERATOR_MODULO:
			{
				Indent(parOss, parIndentLevel) << '%' << std::endl;
			}
			break ;
		default:
			assert(false);
			break ;
		};

		}	
		break ;
    case TOdlAstNodeType::IDENTIFIER:
        {
            parOss << FValueIdentifier << std::endl;
        }
        break ;
    case TOdlAstNodeType::VALUE_STRING:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

			parOss << "\"";
            parOss << FValueString.c_str();
			parOss << "\"";

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_INTEGER:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss << FValueInteger;

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_FLOAT:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
				parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss << FValueFloat;

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
	case TOdlAstNodeType::VALUE_VECTOR:
		{
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

			parOss << '[';
			for (int i = 0; i < (int) FVectorContent.size(); ++i)
            {
                // PAUL(15/05/14 18:19:11) les items sont stockés à l'envers 
                // (description de la grammaire permet de supporter la notation [ expression , ]
                int const invI = (int) FVectorContent.size() - i - 1;
                TOdlAstNode const* item = FVectorContent[invI];
                item->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
				if (i + 1 != FVectorContent.size())
					parOss << ", ";
            }
			parOss << ']';

            if (!anonymous)
            {
                parOss << std::endl;
            }
		}
		break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
			parOss << FIdentifierPointer->Identifier();
            parOss << " = ";

            int const propertyLengthPlusSpacePlusEqualPlusSpace = (int) FIdentifierPointer->Identifier().length() + 3;
            FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + propertyLengthPlusSpacePlusEqualPlusSpace);
            // yuk.
            if (FExpressionPointer->AstNodeType() != TOdlAstNodeType::EXPRESSION)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION_LIST:
        {
            for (size_t i = 0; i < FPropertyList.size(); ++i)
            {
                TOdlAstNode const* child = FPropertyList[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
        }
        break ;
    case TOdlAstNodeType::OBJECT_DECLARATION:
        {
			if (IsNullPtr())
			{
				parOss << "<nullptr>" << std::endl;
			}
			else
			{
				if (FIdentifierPointer != nullptr)
				{
					parOss << "[";
					parOss << FIdentifierPointer->Identifier();
					parOss << "] ";
				}

				parOss << FTypeIdentifierPointer->Identifier() << std::endl;

				Indent(parOss, parIndentLevel) << "{" << std::endl;
				FPropertyDeclarationListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
				Indent(parOss, parIndentLevel) << "}";
				parOss << std::endl;
			}
        }
        break ;
    case TOdlAstNodeType::NAMESPACE:
        {
            Indent(parOss, parIndentLevel) << "namespace ";
            if (FIdentifierPointer != nullptr)
            {
				parOss << FIdentifierPointer->Identifier();
            }
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            for (size_t i = 0; i < FNamedDeclarationList.size(); ++i)
            {
                TOdlAstNode const* child = FNamedDeclarationList[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            }
            Indent(parOss, parIndentLevel) << "}" << std::endl;
			parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::NAMED_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
			parOss << FIdentifierPointer->Identifier();
			parOss << " is ";
			int const identifierLengthPlusSpaceIsSpace = (int) FIdentifierPointer->Identifier().length() + 4;
			FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + identifierLengthPlusSpaceIsSpace);
			parOss << std::endl;
        }
        break ;
    };
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsReferenceToResolve()
{
	FReferenceToResolve = true;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::ResolveReference(TOdlAstNode* parNodeReference)
{
	FResolvedReferenceWeak = parNodeReference; 
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetFullDatabasePath(TOdlDatabasePath const& parFullDatabasePath)
{
	FFullDatabasePath = parFullDatabasePath;
}
//-------------------------------------------------------------------------------
bool TOdlAstNode::IsGlobalNamespace() const
{
	assert(FAstNodeType == TOdlAstNodeType::NAMESPACE);
	return FIdentifierPointer == nullptr;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::BreakPoint()
{
	int a = 0;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
} // namespace odl
