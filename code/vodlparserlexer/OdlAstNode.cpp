#include "BasicTypes.h"
#include "OdlAstNode.h"


namespace odl
{
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
static odl::TOdlAstNodeIdentifier* AutoGenerateObjectIdentifier()
{
    static unsigned int number = 0;
    char buffer[64];
    sprintf_s(buffer, "autoname#%010u", number);
    number++;

    odl::TOdlAstNodeIdentifier* autoGeneratedIdentifier = new odl::TOdlAstNodeIdentifier(std::string(buffer));
    return autoGeneratedIdentifier;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode(TOdlAstNodeType::TType parAstNodeType) :
    FAstNodeType(parAstNodeType),
    FTargetTemplateNamespaceIdentifierPointer(nullptr),
    FExpressionPointer(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FIsValueReference(false) 
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode() :
    FAstNodeType(TOdlAstNodeType::UNKNOWN),
    FTargetTemplateNamespaceIdentifierPointer(nullptr),
    FExpressionPointer(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FIsValueReference(false)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::~TOdlAstNode()
{

    delete FTargetTemplateNamespaceIdentifierPointer;
    delete FExpressionPointer;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrint(std::ostringstream& parOss) const
{
    PrettyPrintWithIndentLevel(parOss, 0);
}
//-------------------------------------------------------------------------------
std::ostringstream& Indent(std::ostringstream& parOss, int parIndentLevel)
{
    for (int i = 0; i < parIndentLevel; ++i)
    {
        parOss << ".";
    }

    return parOss;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrintWithIndentLevel(std::ostringstream& parOss, int parIndentLevel) const
{
    switch (FAstNodeType)
    {
    case TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST:
        {
            TOdlAstNodeTemplateExpressionList const* that = CastNode<TOdlAstNodeTemplateExpressionList>();
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNodeExpression const* parameter : that->TemplateExpressionParameterList())
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                parameter->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
            parOss << ')';
        }
        break ;
    case TOdlAstNodeType::OBJECT_TEMPLATE_INSTANCIATION:
        {
            TOdlAstNodeTemplateObjectInstanciation const* that = CastNode<TOdlAstNodeTemplateObjectInstanciation>();
            parOss << that->TypeIdentifierPointer()->Identifier(); // template name.
            that->TemplateExpressionListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;    
        }
        break ;
    case TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST:
        {
            TOdlAstNodeTemplateParameterList const* that = CastNode<TOdlAstNodeTemplateParameterList>();
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNodeTemplateParameter const* parameter : that->TemplateParameterList())
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                parOss << parameter->IdentifierPointer()->Identifier();
            }
            parOss << ')';
        }
        break;
    case TOdlAstNodeType::OBJECT_TEMPLATE_DECLARATION:
        {
            TOdlAstNodeTemplateObjectDeclaration const* that = CastNode<TOdlAstNodeTemplateObjectDeclaration>();
            
            Indent(parOss, parIndentLevel);
            parOss << "template ";
            parOss << that->IdentifierPointer()->Identifier();
            parOss << " is ";
            parOss << that->TypeIdentifierPointer()->Identifier();
            that->TemplateParameterListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            that->PropertyDeclarationListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel) << "}";
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::OPERATION:
        {
            //bool anonymous = FIdentifierPointer == nullptr;
            //if (!anonymous)
            //{
            //    Indent(parOss, parIndentLevel);
            //    parOss << FIdentifierPointer->Identifier();
            //    parOss << " is ";
            //    int const propertyLengthPlusSpacePlusIsPlusSpace = (int) FIdentifierPointer->Identifier().length() + 4;
            //    parIndentLevel += propertyLengthPlusSpacePlusIsPlusSpace;
            //}

            parOss << "(" << std::endl;
            if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer() != nullptr)
            {
                Indent(parOss, parIndentLevel + 4);
                CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->AstNodeType() != TOdlAstNodeType::OPERATION)
                    parOss << std::endl;
            }
            CastNode<TOdlAstNodeOperation>()->OperatorExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel + 4);
            CastNode<TOdlAstNodeOperation>()->RightExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << ")" << std::endl;
        }
        break ;
    case TOdlAstNodeType::OPERATOR:
    {
        TOdlAstNodeOperatorType::TType operatorType = CastNode<TOdlAstNodeOperator>()->OperatorType();
        switch (operatorType)
        {
        case TOdlAstNodeOperatorType::OPERATOR_PLUS:
            {
                Indent(parOss, parIndentLevel) << '+' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MINUS:
            {
                Indent(parOss, parIndentLevel) << '-' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MULTIPLY:
            {
                Indent(parOss, parIndentLevel) << '*' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_DIVIDE:
            {
                Indent(parOss, parIndentLevel) << '/' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MODULO:
            {
                Indent(parOss, parIndentLevel) << '%' << std::endl;
            }
            break ;
        default:
            assert(false);
            break ;
        };

        }    
        break ;
    case TOdlAstNodeType::IDENTIFIER:
        {
            TOdlAstNodeIdentifier const* nodeIdentifier = CastNode<TOdlAstNodeIdentifier>();
            parOss << nodeIdentifier->Identifier() << std::endl;
        }
        break ;
    case TOdlAstNodeType::VALUE_STRING:
        {
            /*
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }*/

            parOss << "\"";
            parOss << this->CastNode<TOdlAstNodeValue>()->ValueString().c_str();
            parOss << "\"";

            /*if (!anonymous)
            {
                parOss << std::endl;
            }*/
        }
        break ;
    case TOdlAstNodeType::VALUE_INTEGER:
        {
            /*bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }*/

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueInteger();

            //if (!anonymous)
            //{
            //    parOss << std::endl;
            //}
        }
        break ;
    case TOdlAstNodeType::VALUE_FLOAT:
        {
            //bool anonymous = FIdentifierPointer == nullptr;
            //if (!anonymous)
            //{
            //    Indent(parOss, parIndentLevel);
            //    parOss << FIdentifierPointer->Identifier();
            //    parOss << " is ";
            //}

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueFloat();

            //if (!anonymous)
            //{
            //    parOss << std::endl;
            //}
        }
        break ;
    case TOdlAstNodeType::VALUE_VECTOR:
        {
            //bool anonymous = FIdentifierPointer == nullptr;
            //if (!anonymous)
            //{
            //    Indent(parOss, parIndentLevel);
            //    parOss << FIdentifierPointer->Identifier();
            //    parOss << " is ";
            //}


            TOdlAstNodeValueVector const* valueVectorNode = CastNode<TOdlAstNodeValueVector>();
            std::vector< TOdlAstNodeExpression* > const& vectorContent = valueVectorNode->VectorContent();
            parOss << '[';
            for (int i = 0; i < (int) vectorContent.size(); ++i)
            {
                // PAUL(15/05/14 18:19:11) les items sont stockés à l'envers 
                // (description de la grammaire permet de supporter la notation [ expression , ]
                int const invI = (int) vectorContent.size() - i - 1;
                TOdlAstNode const* item = vectorContent[invI];
                item->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
                if (i + 1 != vectorContent.size())
                    parOss << ", ";
            }
            parOss << ']';

 /*           if (!anonymous)
            {
                parOss << std::endl;
            }*/
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION:
        {
            TOdlAstNodePropertyDeclaration const* propertyDeclarationNode = this->CastNode<TOdlAstNodePropertyDeclaration>();

            Indent(parOss, parIndentLevel);
            parOss << propertyDeclarationNode->IdentifierPointer()->Identifier();
            parOss << " = ";

            int const propertyLengthPlusSpacePlusEqualPlusSpace = (int) propertyDeclarationNode->IdentifierPointer()->Identifier().length() + 3;
            FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + propertyLengthPlusSpacePlusEqualPlusSpace);
            // yuk.
            if (FExpressionPointer->AstNodeType() != TOdlAstNodeType::OPERATION)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION_LIST:
        {
            TOdlAstNodePropertyDeclarationList const* that = CastNode<TOdlAstNodePropertyDeclarationList >();
            std::vector< TOdlAstNodePropertyDeclaration* > const& properties = that->PropertyDeclarationList();
            for (size_t i = 0; i < properties.size(); ++i)
            {
                TOdlAstNodePropertyDeclaration const* child = properties[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
        }
        break ;
    case TOdlAstNodeType::OBJECT_DECLARATION:
        {
            TOdlAstNodeObjectDeclaration const* that = CastNode<TOdlAstNodeObjectDeclaration>();

            if (that->IsNullPtr())
            {
                parOss << "<nullptr>" << std::endl;
            }
            else
            {
                //if (FIdentifierPointer != nullptr)
                //{
                //    parOss << "[";
                //    parOss << FIdentifierPointer->Identifier();
                //    parOss << "] ";
                //}

                parOss << that->TypeIdentifierPointer()->Identifier() << std::endl;

                Indent(parOss, parIndentLevel) << "{" << std::endl;
                that->PropertyDeclarationListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                Indent(parOss, parIndentLevel) << "}";
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::NAMESPACE:
        {
            TOdlAstNodeNamespaceDeclaration const* namespaceDeclarationNode = CastNode<TOdlAstNodeNamespaceDeclaration>();

            Indent(parOss, parIndentLevel) << "namespace ";

            TOdlAstNodeIdentifier const* identifierNode = namespaceDeclarationNode->IdentifierPointer();
            if (identifierNode != nullptr)
            {
                parOss << identifierNode->Identifier();
            }

            TOdlAstNode const* templateParameterListPointer = namespaceDeclarationNode->TemplateParameterListPointer();
            if (templateParameterListPointer != nullptr)
            {
                templateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }

            parOss << std::endl;
            std::vector< TOdlAstNodeNamedDeclaration* > const& namedDeclarations = namespaceDeclarationNode->NamespaceContent();
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            for (size_t i = 0; i < namedDeclarations.size(); ++i)
            {
                TOdlAstNode const* child = namedDeclarations[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            }
            Indent(parOss, parIndentLevel) << "}" << std::endl;
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::NAMED_DECLARATION:
        {
            TOdlAstNodeNamedDeclaration const* namedDeclarationNode = CastNode<TOdlAstNodeNamedDeclaration>();
            Indent(parOss, parIndentLevel);

            TOdlAstNodeIdentifier const* identifierNode = namedDeclarationNode->IdentifierPointer();
            TOdlAstNodeExpression const* expressionNode = namedDeclarationNode->ExpressionPointer();

            parOss << identifierNode->Identifier();
            parOss << " is ";
            int const identifierLengthPlusSpaceIsSpace = (int) identifierNode->Identifier().length() + 4;
            expressionNode->PrettyPrintWithIndentLevel(parOss, parIndentLevel + identifierLengthPlusSpaceIsSpace);
            parOss << std::endl;
        }
        break ;
    };
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetFullDatabasePath(TOdlDatabasePath const& parFullDatabasePath)
{
    FFullDatabasePath = parFullDatabasePath;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::BreakPoint()
{
    int a = 0;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
void TOdlAstNodeNamedDeclaration::AutoGenerateIdentifier()
{
    assert(FIdentifier == nullptr);
    FIdentifier = AutoGenerateObjectIdentifier();
    FAnonymousDeclaration = true;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------

} // namespace odl
