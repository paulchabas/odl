#include "BasicTypes.h"
#include "OdlAstNode.h"


namespace odl
{
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
static odl::TOdlAstNodeIdentifier* AutoGenerateObjectIdentifier()
{
    static unsigned int number = 0;
    char buffer[64];
    sprintf_s(buffer, "autoname#%010u", number);
    number++;

    odl::TOdlAstNodeIdentifier* autoGeneratedIdentifier = new odl::TOdlAstNodeIdentifier(std::string(buffer));
    return autoGeneratedIdentifier;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode(TOdlAstNodeType::TType parAstNodeType) :
    FAstNodeType(parAstNodeType)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode() :
    FAstNodeType(TOdlAstNodeType::UNKNOWN)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::~TOdlAstNode()
{

}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrint(std::ostringstream& parOss) const
{
    PrettyPrintWithIndentLevel(parOss, 0);
}
//-------------------------------------------------------------------------------
std::ostringstream& Indent(std::ostringstream& parOss, int parIndentLevel)
{
    for (int i = 0; i < parIndentLevel; ++i)
    {
        parOss << ".";
    }

    return parOss;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrintWithIndentLevel(std::ostringstream& parOss, int parIndentLevel) const
{
    switch (FAstNodeType)
    {
    case TOdlAstNodeType::TEMPLATE_INSTANCIATION_EXPRESSION_LIST:
        {
            TOdlAstNodeTemplateExpressionList const* that = CastNode<TOdlAstNodeTemplateExpressionList>();
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNodeExpression const* parameter : that->TemplateExpressionParameterList())
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                parameter->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
            parOss << ')';
        }
        break ;
    case TOdlAstNodeType::TEMPLATE_OBJECT_INSTANCIATION:
        {
            TOdlAstNodeTemplateObjectInstanciation const* that = CastNode<TOdlAstNodeTemplateObjectInstanciation>();
            parOss << that->TypeIdentifierPointer()->Identifier(); // template name.
            that->TemplateExpressionListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;    
        }
        break ;
    case TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST:
        {
            TOdlAstNodeTemplateParameterList const* that = CastNode<TOdlAstNodeTemplateParameterList>();
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNodeTemplateParameter const* parameter : that->TemplateParameterList())
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                parOss << parameter->IdentifierPointer()->Identifier();
            }
            parOss << ')';
        }
        break;
    case TOdlAstNodeType::TEMPLATE_OBJECT_DECLARATION:
        {
            TOdlAstNodeTemplateObjectDeclaration const* that = CastNode<TOdlAstNodeTemplateObjectDeclaration>();
            
            parOss << "template ";
            parOss << that->IdentifierPointer()->Identifier();
            parOss << " is ";
            parOss << that->TypeIdentifierPointer()->Identifier();
            that->TemplateParameterListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            that->PropertyDeclarationListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel) << "}";
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::OPERATION:
        {
            //bool anonymous = FIdentifierPointer == nullptr;
            //if (!anonymous)
            //{
            //    Indent(parOss, parIndentLevel);
            //    parOss << FIdentifierPointer->Identifier();
            //    parOss << " is ";
            //    int const propertyLengthPlusSpacePlusIsPlusSpace = (int) FIdentifierPointer->Identifier().length() + 4;
            //    parIndentLevel += propertyLengthPlusSpacePlusIsPlusSpace;
            //}

            parOss << "(" << std::endl;
            if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer() != nullptr)
            {
                Indent(parOss, parIndentLevel + 4);
                CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->AstNodeType() != TOdlAstNodeType::OPERATION)
                    parOss << std::endl;
            }
            CastNode<TOdlAstNodeOperation>()->OperatorExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel + 4);
            CastNode<TOdlAstNodeOperation>()->RightExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << ")" << std::endl;
        }
        break ;
    case TOdlAstNodeType::OPERATOR:
    {
        TOdlAstNodeOperatorType::TType operatorType = CastNode<TOdlAstNodeOperator>()->OperatorType();
        switch (operatorType)
        {
        case TOdlAstNodeOperatorType::OPERATOR_PLUS:
            {
                Indent(parOss, parIndentLevel) << '+' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MINUS:
            {
                Indent(parOss, parIndentLevel) << '-' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MULTIPLY:
            {
                Indent(parOss, parIndentLevel) << '*' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_DIVIDE:
            {
                Indent(parOss, parIndentLevel) << '/' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MODULO:
            {
                Indent(parOss, parIndentLevel) << '%' << std::endl;
            }
            break ;
        default:
            assert(false);
            break ;
        };

        }    
        break ;
    case TOdlAstNodeType::IDENTIFIER:
        {
            TOdlAstNodeIdentifier const* nodeIdentifier = CastNode<TOdlAstNodeIdentifier>();
            std::string const& identifier = nodeIdentifier->Identifier();
            parOss << identifier;
        }
        break ;
    case TOdlAstNodeType::VALUE_STRING:
        {
            /*
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }*/

            parOss << "\"";
            parOss << this->CastNode<TOdlAstNodeValue>()->ValueString().c_str();
            parOss << "\"";

            /*if (!anonymous)
            {
                parOss << std::endl;
            }*/
        }
        break ;
    case TOdlAstNodeType::VALUE_INTEGER:
        {
            /*bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }*/

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueInteger();

            //if (!anonymous)
            //{
            //    parOss << std::endl;
            //}
        }
        break ;
    case TOdlAstNodeType::VALUE_FLOAT:
        {
            //bool anonymous = FIdentifierPointer == nullptr;
            //if (!anonymous)
            //{
            //    Indent(parOss, parIndentLevel);
            //    parOss << FIdentifierPointer->Identifier();
            //    parOss << " is ";
            //}

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueFloat();

            //if (!anonymous)
            //{
            //    parOss << std::endl;
            //}
        }
        break ;
    case TOdlAstNodeType::VALUE_VECTOR:
        {
            //bool anonymous = FIdentifierPointer == nullptr;
            //if (!anonymous)
            //{
            //    Indent(parOss, parIndentLevel);
            //    parOss << FIdentifierPointer->Identifier();
            //    parOss << " is ";
            //}


            TOdlAstNodeValueVector const* valueVectorNode = CastNode<TOdlAstNodeValueVector>();
            std::vector< TOdlAstNodeExpression* > const& vectorContent = valueVectorNode->VectorContent();
            parOss << '[';
            for (int i = 0; i < (int) vectorContent.size(); ++i)
            {
                // PAUL(15/05/14 18:19:11) les items sont stockés à l'envers 
                // (description de la grammaire permet de supporter la notation [ expression , ]
                int const invI = (int) vectorContent.size() - i - 1;
                TOdlAstNode const* item = vectorContent[invI];
                item->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
                if (i + 1 != vectorContent.size())
                    parOss << ", ";
            }
            parOss << ']';

 /*           if (!anonymous)
            {
                parOss << std::endl;
            }*/
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION:
        {
            TOdlAstNodePropertyDeclaration const* propertyDeclarationNode = this->CastNode<TOdlAstNodePropertyDeclaration>();
            TOdlAstNodeIdentifier const* identifierNode = propertyDeclarationNode->IdentifierPointer();
            TOdlAstNodeExpression const* expressionNode = propertyDeclarationNode->ExpressionPointer();

            Indent(parOss, parIndentLevel);
            parOss << identifierNode->Identifier();
            parOss << " = ";

            int const propertyLengthPlusSpacePlusEqualPlusSpace = (int) identifierNode->Identifier().length() + 3;
            expressionNode->PrettyPrintWithIndentLevel(parOss, parIndentLevel + propertyLengthPlusSpacePlusEqualPlusSpace);
            // yuk.
            if (expressionNode->AstNodeType() != TOdlAstNodeType::OPERATION)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION_LIST:
        {
            TOdlAstNodePropertyDeclarationList const* that = CastNode<TOdlAstNodePropertyDeclarationList >();
            std::vector< TOdlAstNodePropertyDeclaration* > const& properties = that->PropertyDeclarationList();
            for (size_t i = 0; i < properties.size(); ++i)
            {
                TOdlAstNodePropertyDeclaration const* child = properties[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
        }
        break ;
    case TOdlAstNodeType::OBJECT_DECLARATION:
        {
            TOdlAstNodeObjectDeclaration const* that = CastNode<TOdlAstNodeObjectDeclaration>();

            if (that->IsNullPtr())
            {
                parOss << "<nullptr>";
            }
            else
            {
                parOss << that->NamedDeclarationWeakRef()->IdentifierPointer()->Identifier();
                parOss << " is ";
                parOss << that->TypeIdentifierPointer()->Identifier() << std::endl;

                Indent(parOss, parIndentLevel) << "{" << std::endl;
                that->PropertyDeclarationListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                Indent(parOss, parIndentLevel) << "}";

                if (!that->NamedDeclarationWeakRef()->IsAnonymousDeclaration())
                    parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::NAMESPACE:
        {
            TOdlAstNodeNamespaceDeclaration const* namespaceDeclarationNode = CastNode<TOdlAstNodeNamespaceDeclaration>();

            Indent(parOss, parIndentLevel) << "namespace ";

            TOdlAstNodeIdentifier const* identifierNode = namespaceDeclarationNode->IdentifierPointer_IFP();
            if (identifierNode != nullptr)
            {
                parOss << identifierNode->Identifier();
            }

            TOdlAstNode const* templateParameterListPointer = namespaceDeclarationNode->TemplateParameterListPointer();
            if (templateParameterListPointer != nullptr)
            {
                templateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }

            parOss << std::endl;
            std::vector< TOdlAstNodeNamedDeclaration* > const& namedDeclarations = namespaceDeclarationNode->NamespaceContent();
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            for (size_t i = 0; i < namedDeclarations.size(); ++i)
            {
                TOdlAstNode const* child = namedDeclarations[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            }
            Indent(parOss, parIndentLevel) << "}" << std::endl;
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::NAMED_DECLARATION:
        {
            TOdlAstNodeNamedDeclaration const* namedDeclarationNode = CastNode<TOdlAstNodeNamedDeclaration>();
            TOdlAstNodeIdentifier const* identifierNode = namedDeclarationNode->IdentifierPointer();
            TOdlAstNodeExpression const* expressionNode = namedDeclarationNode->ExpressionPointer();

            // Paul(2014/12/24) has the grammar a bad consistency or the way of formatting a human readable output is really tricky ?
            bool printIdentifierIsNow = true;
            {
                if (expressionNode->AstNodeType() == TOdlAstNodeType::OBJECT_DECLARATION ||
                    expressionNode->AstNodeType() == TOdlAstNodeType::TEMPLATE_OBJECT_DECLARATION)
                {
                    printIdentifierIsNow = false;
                }
            }

            // Paul(2014/12/24) has the grammar a bad consistency or the way of formatting a human readable output is really tricky ?
            {
                bool const indent = !namedDeclarationNode->IsAnonymousDeclaration();
                if (indent)
                    Indent(parOss, parIndentLevel);
            }

            // Paul(2014/12/24) has the grammar a bad consistency or the way of formatting a human readable output is really tricky ?
            int additionnalIndentation = 0;
            {
                if (printIdentifierIsNow)
                {
                    std::string const& identifier = identifierNode->Identifier();
                    parOss << identifier;
                    parOss << " is ";
                    int const identifierLengthPlusSpaceIsSpace = (int) identifierNode->Identifier().length() + 4;
                    additionnalIndentation = identifierLengthPlusSpaceIsSpace;
                }
            }
            
            expressionNode->PrettyPrintWithIndentLevel(parOss, parIndentLevel + additionnalIndentation);

            // Paul(2014/12/24) has the grammar a bad consistency or the way of formatting a human readable output is really tricky ?
            {
                bool additionnalEndLine1 = true;
                bool additionnalEndLine2 = true;
                if (expressionNode->AstNodeType() == TOdlAstNodeType::TEMPLATE_OBJECT_DECLARATION)
                {
                    additionnalEndLine2 = false;
                }
                else if (expressionNode->AstNodeType() == TOdlAstNodeType::OBJECT_DECLARATION)
                {
                    TOdlAstNodeObjectDeclaration const* objectDeclaration = expressionNode->CastNode<TOdlAstNodeObjectDeclaration>();
                    //if (!objectDeclaration->IsNullPtr())
                        additionnalEndLine2 = false;
                }
                else if (expressionNode->AstNodeType() == TOdlAstNodeType::OPERATION)
                {
                    additionnalEndLine1 = false;

                    if (namedDeclarationNode->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION)
                        additionnalEndLine2 = false;
                }

                if (additionnalEndLine1)
                    parOss << std::endl;
                if (additionnalEndLine2)
                    parOss << std::endl;
            }
        }
        break ;
    };
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
void TOdlAstNodeNamedDeclaration::AutoGenerateIdentifierIfNone()
{
    if (FIdentifier == nullptr)
    {
        FIdentifier = AutoGenerateObjectIdentifier();
        FAnonymousDeclaration = true;
    }
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------

} // namespace odl
