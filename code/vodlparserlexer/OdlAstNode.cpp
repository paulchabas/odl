#include "BasicTypes.h"
#include "OdlAstNode.h"


namespace odl
{
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
static odl::TOdlAstNodeIdentifier* AutoGenerateObjectIdentifier()
{
    static unsigned int number = 0;
    char buffer[64];
    sprintf_s(buffer, "autoname#%010u", number);
    number++;

    odl::TOdlAstNodeIdentifier* autoGeneratedIdentifier = new odl::TOdlAstNodeIdentifier(std::string(buffer));
    return autoGeneratedIdentifier;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode(TOdlAstNodeType::TType parAstNodeType) :
    FAstNodeType(parAstNodeType),
    FPropertyList(),
    FIdentifierPointer(nullptr),
    FTargetTemplateNamespaceIdentifierPointer(nullptr),
    FExpressionPointer(nullptr),
    FResolvedReferenceWeak(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FReferenceToResolve(false),
    FIsValueReference(false),
    FIsTemplateDeclarationParameter(false)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::TOdlAstNode() :
    FAstNodeType(TOdlAstNodeType::UNKNOWN),
    FPropertyList(),
    FIdentifierPointer(nullptr),
    //FTypeIdentifierPointer(nullptr),
    FTargetTemplateNamespaceIdentifierPointer(nullptr),
    FExpressionPointer(nullptr),
    FResolvedReferenceWeak(nullptr),
    FAnonymousDeclaration(true), // value reset by named declarations.
    FReferenceToResolve(false),
    FIsValueReference(false),
    FIsTemplateDeclarationParameter(false)
{

}
//-------------------------------------------------------------------------------
TOdlAstNode::~TOdlAstNode()
{
    for (size_t i = 0; i < FPropertyList.size(); ++i)
    {
        TOdlAstNode const* node = FPropertyList[i];
        delete node;
    }

    for (size_t i = 0; i < FTemplateParameterList.size(); ++i)
    {
        TOdlAstNode const* node = FTemplateParameterList[i];
        delete node;
    }
    
    delete FIdentifierPointer;
    delete FTargetTemplateNamespaceIdentifierPointer;
    delete FExpressionPointer;

    FResolvedReferenceWeak = nullptr; // weak reference.
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetIdentifierPointer(TOdlAstNodeIdentifier* parIdentifierPointer)
{
    assert(FIdentifierPointer == nullptr);
    FIdentifierPointer = parIdentifierPointer;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::AutoGenerateIdentifier()
{
    assert(FIdentifierPointer == nullptr);
    FIdentifierPointer = AutoGenerateObjectIdentifier();
    FAnonymousDeclaration = true;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateDeclarationParameterList()
{
    FAstNodeType = TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::TemplateDeclarationParameterList_AppendParameter(TOdlAstNodeIdentifier* parIdentifier)
{
    assert(FAstNodeType == TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST);
    assert(parIdentifier->IsTemplateDeclarationParameter());
    FTemplateParameterList.push_back(parIdentifier);
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::SetAsTemplateInstanciationParameterList()
{
    FAstNodeType = TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::TemplateInstanciationParameterList_AppendParameter(TOdlAstNode* parExpression)
{
    assert(FAstNodeType == TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST);

    assert(parExpression != nullptr);
    assert((parExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION_MASK) != 0);
    FTemplateParameterList.push_back(parExpression);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsNamedDeclaration(TOdlAstNodeIdentifier* parNameIdentifier, TOdlAstNode* parExpression)
{
    FAstNodeType = TOdlAstNodeType::NAMED_DECLARATION;
    
    assert(parExpression != nullptr);
    assert(parNameIdentifier != nullptr);

    FIdentifierPointer = parNameIdentifier;
    FExpressionPointer = parExpression;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsPropertyDeclarationList()
{
    FAstNodeType = TOdlAstNodeType::PROPERTY_DECLARATION_LIST;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PropertyDeclarationList_AppendPropertyDeclaration(TOdlAstNode* parPropertyDeclarationNode)
{
    assert(FAstNodeType == TOdlAstNodeType::PROPERTY_DECLARATION_LIST);
    assert(parPropertyDeclarationNode != nullptr);
    assert(parPropertyDeclarationNode->AstNodeType() == TOdlAstNodeType::PROPERTY_DECLARATION);
    FPropertyList.push_back(parPropertyDeclarationNode);
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsPropertyDeclaration(TOdlAstNodeIdentifier* parIdentifier, TOdlAstNode* parExpression)
{
    assert(parIdentifier != nullptr);
    assert(parIdentifier->AstNodeType() == TOdlAstNodeType::IDENTIFIER);
    assert(parExpression != nullptr);
    assert(parExpression->AstNodeType() & TOdlAstNodeType::EXPRESSION);

    FAstNodeType = TOdlAstNodeType::PROPERTY_DECLARATION;
    FIdentifierPointer = parIdentifier;
    FExpressionPointer = parExpression;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrint(std::ostringstream& parOss) const
{
    PrettyPrintWithIndentLevel(parOss, 0);
}
//-------------------------------------------------------------------------------
std::ostringstream& Indent(std::ostringstream& parOss, int parIndentLevel)
{
    for (int i = 0; i < parIndentLevel; ++i)
    {
        parOss << ".";
    }

    return parOss;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::PrettyPrintWithIndentLevel(std::ostringstream& parOss, int parIndentLevel) const
{
    switch (FAstNodeType)
    {
    case TOdlAstNodeType::TEMPLATE_INSTANCIATION_PARAMETER_LIST:
        {
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNode const* parameter : FTemplateParameterList)
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                parameter->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
            parOss << ')';
        }
        break ;
    case TOdlAstNodeType::OBJECT_TEMPLATE_INSTANCIATION:
        {
            TOdlAstNodeTemplateObjectInstanciation const* that = CastNode<TOdlAstNodeTemplateObjectInstanciation>();
            parOss << that->TypeIdentifierPointer()->Identifier(); // template name.
            that->TemplateParameterListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;    
        }
        break ;
    case TOdlAstNodeType::TEMPLATE_DECLARATION_PARAMETER_LIST:
        {
            parOss << '(';
            bool printComma = false;
            for (TOdlAstNode const* parameter : FTemplateParameterList)
            {
                if (printComma)
                    parOss << ", ";
                printComma = true;
                // {TODO} Paul(2014/12/21) strong typing.
                parOss << parameter->CastNode<TOdlAstNodeIdentifier>()->Identifier();
            }
            parOss << ')';
        }
        break;
    case TOdlAstNodeType::OBJECT_TEMPLATE_DECLARATION:
        {
            TOdlAstNodeTemplateObjectDeclaration const* that = CastNode<TOdlAstNodeTemplateObjectDeclaration>();
            
            Indent(parOss, parIndentLevel);
            parOss << "template ";
            parOss << that->IdentifierPointer()->Identifier();
            parOss << " is ";
            parOss << that->TypeIdentifierPointer()->Identifier();
            that->TemplateParameterListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            that->PropertyDeclarationListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel) << "}";
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::EXPRESSION:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
                int const propertyLengthPlusSpacePlusIsPlusSpace = (int) FIdentifierPointer->Identifier().length() + 4;
                parIndentLevel += propertyLengthPlusSpacePlusIsPlusSpace;
            }

            parOss << "(" << std::endl;
            if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer() != nullptr)
            {
                Indent(parOss, parIndentLevel + 4);
                CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                if (CastNode<TOdlAstNodeOperation>()->LeftExpressionPointer()->AstNodeType() != TOdlAstNodeType::EXPRESSION)
                    parOss << std::endl;
            }
            CastNode<TOdlAstNodeOperation>()->OperatorExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            Indent(parOss, parIndentLevel + 4);
            CastNode<TOdlAstNodeOperation>()->RightExpressionPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            parOss << std::endl;
            Indent(parOss, parIndentLevel) << ")" << std::endl;
        }
        break ;
    case TOdlAstNodeType::OPERATOR:
    {
        TOdlAstNodeOperatorType::TType operatorType = CastNode<TOdlAstNodeOperator>()->OperatorType();
        switch (operatorType)
        {
        case TOdlAstNodeOperatorType::OPERATOR_PLUS:
            {
                Indent(parOss, parIndentLevel) << '+' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MINUS:
            {
                Indent(parOss, parIndentLevel) << '-' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MULTIPLY:
            {
                Indent(parOss, parIndentLevel) << '*' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_DIVIDE:
            {
                Indent(parOss, parIndentLevel) << '/' << std::endl;
            }
            break ;
        case TOdlAstNodeOperatorType::OPERATOR_MODULO:
            {
                Indent(parOss, parIndentLevel) << '%' << std::endl;
            }
            break ;
        default:
            assert(false);
            break ;
        };

        }    
        break ;
    case TOdlAstNodeType::IDENTIFIER:
        {
            TOdlAstNodeIdentifier const* nodeIdentifier = CastNode<TOdlAstNodeIdentifier>();
            parOss << nodeIdentifier->Identifier() << std::endl;
        }
        break ;
    case TOdlAstNodeType::VALUE_STRING:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss << "\"";
            parOss << this->CastNode<TOdlAstNodeValue>()->ValueString().c_str();
            parOss << "\"";

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_INTEGER:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueInteger();

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_FLOAT:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }

            parOss <<  this->CastNode<TOdlAstNodeValue>()->ValueFloat();

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::VALUE_VECTOR:
        {
            bool anonymous = FIdentifierPointer == nullptr;
            if (!anonymous)
            {
                Indent(parOss, parIndentLevel);
                parOss << FIdentifierPointer->Identifier();
                parOss << " is ";
            }


            TOdlAstNodeValueVector const* valueVectorNode = CastNode<TOdlAstNodeValueVector>();
            std::vector< TOdlAstNodeExpression* > const& vectorContent = valueVectorNode->VectorContent();
            parOss << '[';
            for (int i = 0; i < (int) vectorContent.size(); ++i)
            {
                // PAUL(15/05/14 18:19:11) les items sont stockés à l'envers 
                // (description de la grammaire permet de supporter la notation [ expression , ]
                int const invI = (int) vectorContent.size() - i - 1;
                TOdlAstNode const* item = vectorContent[invI];
                item->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
                if (i + 1 != vectorContent.size())
                    parOss << ", ";
            }
            parOss << ']';

            if (!anonymous)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
            parOss << FIdentifierPointer->Identifier();
            parOss << " = ";

            int const propertyLengthPlusSpacePlusEqualPlusSpace = (int) FIdentifierPointer->Identifier().length() + 3;
            FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + propertyLengthPlusSpacePlusEqualPlusSpace);
            // yuk.
            if (FExpressionPointer->AstNodeType() != TOdlAstNodeType::EXPRESSION)
            {
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::PROPERTY_DECLARATION_LIST:
        {
            for (size_t i = 0; i < FPropertyList.size(); ++i)
            {
                TOdlAstNode const* child = FPropertyList[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }
        }
        break ;
    case TOdlAstNodeType::OBJECT_DECLARATION:
        {
            TOdlAstNodeObjectDeclaration const* that = CastNode<TOdlAstNodeObjectDeclaration>();

            if (that->IsNullPtr())
            {
                parOss << "<nullptr>" << std::endl;
            }
            else
            {
                if (FIdentifierPointer != nullptr)
                {
                    parOss << "[";
                    parOss << FIdentifierPointer->Identifier();
                    parOss << "] ";
                }

                parOss << that->TypeIdentifierPointer()->Identifier() << std::endl;

                Indent(parOss, parIndentLevel) << "{" << std::endl;
                that->PropertyDeclarationListPointer()->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
                Indent(parOss, parIndentLevel) << "}";
                parOss << std::endl;
            }
        }
        break ;
    case TOdlAstNodeType::NAMESPACE:
        {
            TOdlAstNodeNamespaceDeclaration const* namespaceDeclarationNode = CastNode<TOdlAstNodeNamespaceDeclaration>();

            Indent(parOss, parIndentLevel) << "namespace ";

            if (FIdentifierPointer != nullptr)
            {
                parOss << FIdentifierPointer->Identifier();
            }

            TOdlAstNode const* templateParameterListPointer = namespaceDeclarationNode->TemplateParameterListPointer();
            if (templateParameterListPointer != nullptr)
            {
                templateParameterListPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel);
            }

            parOss << std::endl;
            std::vector< TOdlAstNode* > const& namedDeclarations = namespaceDeclarationNode->NamespaceContent();
            Indent(parOss, parIndentLevel) << "{" << std::endl;
            for (size_t i = 0; i < namedDeclarations.size(); ++i)
            {
                TOdlAstNode const* child = namedDeclarations[i];
                child->PrettyPrintWithIndentLevel(parOss, parIndentLevel + 4);
            }
            Indent(parOss, parIndentLevel) << "}" << std::endl;
            parOss << std::endl;
        }
        break ;
    case TOdlAstNodeType::NAMED_DECLARATION:
        {
            Indent(parOss, parIndentLevel);
            parOss << FIdentifierPointer->Identifier();
            parOss << " is ";
            int const identifierLengthPlusSpaceIsSpace = (int) FIdentifierPointer->Identifier().length() + 4;
            FExpressionPointer->PrettyPrintWithIndentLevel(parOss, parIndentLevel + identifierLengthPlusSpaceIsSpace);
            parOss << std::endl;
        }
        break ;
    };
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetAsReferenceToResolve()
{
    FReferenceToResolve = true;
}
//-------------------------------------------------------------------------------
void TOdlAstNode::ResolveReference(TOdlAstNode const* parNodeReference)
{
    FResolvedReferenceWeak = parNodeReference; 
}
//-------------------------------------------------------------------------------
void TOdlAstNode::SetFullDatabasePath(TOdlDatabasePath const& parFullDatabasePath)
{
    FFullDatabasePath = parFullDatabasePath;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
void TOdlAstNode::BreakPoint()
{
    int a = 0;
}
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
} // namespace odl
